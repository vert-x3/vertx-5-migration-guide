= Vert.x Core

== Vertx instance customization

An instance of `Vertx` can be customized with a few moving parts:

- cluster manager
- metrics factory
- tracing factory

In {VertX5} customization is achieved by the `VertxBuilder`.

.Customizing with a cluster manager
[source,java]
----
// 4.x
Future<Vertx> f = Vertx.clusteredVertx(
  new VertxOptions().setClusterManager(clusterManager)
);

// 5.0
Future<Vertx> f = Vertx
  .builder()
  .withClusterManager(clusterManager)
  .buildClustered();
----

Likewise, metrics and tracing factories are configured similarly

.Customizing with tracing/metrics factories
[source,java]
----
// 4.x
Vertx vertx = Vertx.vertx(
  new VertxOptions()
    .setMetricsOptions(new MetricsOptions().setEnabled(true).setFactory(factory))
    .setTracingOptions(new TracingOptions().setFactory(factory))
);

// 5.0
Vertx vertx = Vertx
   .builder()
  .withMetrics(factory)
  .withTracer(factory)
  .build();
----

The tracing implementations of {VertX} have been updated accordingly to support customizing with a tracer implementation for this purpose:

.Customizing an instance with an OpenTelemetry instance
[source,java]
----
// 4.x
Vertx vertx = Vertx.vertx(new VertxOptions()
    .setTracingOptions(
      new OpenTelemetryOptions(openTelemetry)
    )
  );

// 5.0
Vertx vertx = Vertx.builder()
 .withTracer(new OpenTelemetryTracingFactory(openTelemetry))
 .build();
----

The metrics implementations of {VertX} have been updated accordingly to support customizing with a metrics implementation for this purpose:

.Customizing an instance with a Dropwizard metrics registry
[source,java]
----
// Before
Vertx vertx = Vertx.vertx(new VertxOptions()
 .setMetricsOptions(new DropwizardMetricsOptions()
   .setMetricsRegistry(myRegistry)
   .setEnabled(true)));

// After
Vertx vertx = Vertx.builder()
  .with(new VertxOptions()
    .setMetricsOptions(new DropwizardMetricsOptions()
    .setEnabled(true)))
  .withMetrics(new DropwizardMetricsFactory(myRegistry))
  .build();
----

== HTTP related changes

=== HTTP/2 connection shutdown handler

The HTTP/2 connection shutdown handler notifies the handler when the connection shutdown begins, previously the handler was notified when after all the connection streams have been closed. The previous behavior can be obtained with the connection close handler.

This allows to be aware of a connection shutdown and take appropriate measures to stop the inflight streams being processed. It also aligns with the behaviour of other shutdown handlers.

=== Removal of HTTP connection shutdown variant without a timeunit

The `HttpConnection#shutdown(long)` variant is removed in favor of `HttpConnection#shutdown(long, TimeUnit)`.

[source,java]
----
// 4.x
connection.shutdown(5 * 1000); // 5 seconds

// 5.0
connection.shutdown(5, TimeUnit.SECONDS); // 5 seconds
----

=== Use of uniform byte distributor for HTTP/2 streams

The default stream byte distributor use stream priorities to determine the amount of bytes to be sent for each stream, this change allows to use a strategy that does not use stream priorities and yields better performance since it consumes less CPU.

The default implementation is now `UniformStreamByteDistributor` instead of `WeightedFairQueueByteDistributor`.

=== Rename HttpClientRequest setTimeout to setIdleTimeout

The request timeout is actually an idle timeout, it has been renamed to avoid confusion.

[source,java]
----
// 4.x
request.setTimeout(timeout);

// 5.0
request.setIdleTimeout(timeout);
----

=== Removal of HttpClient WebSocket methods

`HttpClient` WebSocket methods are moved to a new `WebSocketClient` API.

[source,java]
----
// 4.x
HttpClient httpClient = vertx.createHttpClient();
Future<WebSocket> f = httpClient.webSocket(connectOptions);

// 5.0
WebSocketClient wsClient = vertx.createWebSocketClient();
Future<WebSocket> f = wsClient.connect(connectOptions);
----

=== HTTP client customization

`HttpClient` customization methods have been moved to a new `HttpClientBuilder`:

- `redirectHandler`
- `connectionHandler`

[source,java]
----
// 4.x
HttpClient client = vertx.createHttpClient();
client.connectionHandler(conn -> ...);
client.redirectHandler(request -> ...);

// 5.0
HttpClient client = vertx.httpClientBuilder()
  .withConnectHandler(conn -> ...)
  .withRedirectHandler(request -> ...)
  .build();
----

=== HttpClient API cleanup

In {VertX} {v4x}, `HttpClient` API exposes two distincts API:

- HTTP interactions, like `request` method.
- HTTP client operations, like `updateSSLOptions`

Since {VertX5}, `HttpClient` only retains HTTP interactions, a new `HttpClientAgent` API extends `HttpClient` and exposes
these methods:

[source,java]
----
// 4.x
HttpClient client = vertx.createHttpClient();
client.updateSSLOptions(sslOptions);

// 5.0
HttpClientAgent client = vertx.createHttpClient();
client.updateSSLOptions(sslOptions);
----

=== HttpClient pool configuration

In {VertX} {v4x}, `HttpClientOptions` configures the HTTP/1.x and HTTP/2 pool.

Since {VertX5}, this configuration is done through `PoolOptions`.

[source,java]
----
// 4.x
HttpClient client = vertx.createHttpClient(new HttpClientOptions()
  .setMaxPoolSize(http1MaxPoolSize)
  .setHttp2MaxPoolSize(http2MaxPoolSize)
);

// 5.0
HttpClient client = vertx.createHttpClient(new PoolOptions()
  .setHttp1MaxSize(http1MaxPoolSize)
  .setHttp2MaxSize(http2MaxPoolSize)
);
----

=== Removal of HttpServerResponse close method

The `HttpServerResponse` close method closes the HTTP connection, it can be misleading as there are better API to interact
with the current request/connection lifecycle which are `HttpServerResponse#reset` and `HttpConnection#close.

When the actual HTTP connection must be closed:

[source,java]
----
// 4.x
response.close();

// 5.0
request.connection().close();
----

When the current request/response must be disposed:

[source,java]
----
// 4.x
response.close();

// 5.0
response.reset();
----

=== HTTP stream async methods returns now a future instead of being fluent

A few methods have seen their fluent return type to be changed to a future type instead in order to signal
the completion result:

- `writeCustomFrame`
- `writeContinue`
- `reset`

[source,java]
----
// 4.x
response.writeCustomFrame(12, 134, expectedRecv).end();

// 5.0
response.writeCustomFrame(12, 134, expectedRecv);
response.end();
----

=== New authority property replacing host/port

`HttpClientRequest` and `HttpServerRequest` expose the request authority using a host/port combination for the client
request and a single host header for the server. In addition, this terminology is also confusing with the actual server
host and port.

Those are replaced by a new _authority_ property:

.Client request
[source,java]
----
// 4.x
request.setHost(host).setPort(port);

// 5.0
request.authority(HostAndPort.create(host, port));
----

.Server request
[source,java]
----
// 4.x
String host = request.host(); // host:port string

// 5.0
HostAndPort authority = request.authority();
----

=== HttpServer request and WebSocket streams removal

`HttpServer#requestStream()` and `HttpServer#timeoutStream()` have been removed. These streams were designed for Rx like
 languages and the actually don't provide any benefits.

[source,java]
----
// 4.x
server.requestStream().handler(request -> ...);

// 5.0
server.requestHandler(request -> ...).listen();
----

=== Removal of server WebSocket handshake methods

The server WebSocket API can control handshake implicitly (e.g. sending a message) or explicitly (accept or any WebSocket interaction). This result in a more complex implementation than it should be for such API.

.Accepting a handshake
[source,java]
----
// 4.x
server.webSocketHandler(ws -> {
  ws.accept();
  ws.write();
};

// 5.0
server.webSocketHandshakeHandler(handshake -> {
  handshake.accept();
});
server.webSocketHandler(ws -> {
  ws.write();
};
----

.Rejecting a handshake
[source,java]
----
// 4.x
server.webSocketHandler(ws -> {
  ws.reject();
};

// 5.0
server.webSocketHandshakeHandler(handshake -> {
  handshake.reject();
});
----

== Future

=== CompositeFuture raw Future type removal

`CompositeFuture` methods declare raw `Future` types, e.g. `all(Future,Future) or all(List<Future>>)`, such declarations force the user to cast when using a `List<Future<Something>>`. These methods have been made fully generic, using the wildcard type.

[source,java]
----
List<Future<User>> users = ...

// 4.x
CompositeFuture cf = CompositeFuture.all((List<Future>)users);

// 5.0
CompositeFuture cf = Future.all(users);
----

=== Removal of Future eventually method that takes a function as argument

`Future#eventually` method takes as parameter a `Function<Void, Future<T>>`, this was developed for codegen which does not support `Supplier`. The `Future` object is not code generated anymore since {VertX} {v4x}, we can therefore use `Supplier` which is more suitable.

[source,java]
----
// 4.x
future.eventually(v -> someFuture());

// 5.0
future.eventually(() -> someFuture());
----

== System properties

A few system properties have been removed in Vert.x 5.

|===
|Name|Comment

|`vertx.json.base64`
|Vert.x 3.x Json supports RFC-7493, however the JSON encoder/decoder format was incorrect. Users who needed to interop with Vert.x 3.x applications should have set the system property vertx.json.base64 to legacy

|`vertx.cluster.managerClass`
|not used, neither documented nor tested

|`vertx.javaCompilerOptions`
|not used, neither documented nor tested

|`vertx.flashPolicyHandler`
|{VertX} HTTP/1.1 server contains a hidden option to detect Adobe Flash clients and return a policy file response (http://www.adobe.com/devnet/articles/crossdomain_policy_file_spec.html). This option is activated by a system property vertx.flashPolicyHandler only referenced in source code (private field) and not tested.

|`vertx.cwd`
|this system property was not documented and only used in vertx-examples repository

|`vertx.disableTCCL`
|instead `VertxOptions#setDisableTCCL(boolean)` should be used
|===

== Worker verticles

=== Removal of deployment worker property

`DeploymentOptions#setWorker` and `DeploymentOptions#getWorker` methods are removed since the introduction of the new `ThreadingModel`.

[source,java]
----
// 4.x
Future<String> f = vertx.deployVerticle(new DeploymentOptions().setWorker(true, ...)

// 5.0
Future<String> f = vertx.deployVerticle(new DeploymentOptions().setThreadingModel(ThreadingModel.WORKER, ...)
----

=== Worker event-loop assignment

Since {VertX5} worker deployment uses a single event-loop for all worker verticles instead of an event-loop per worker
instance.

Previously, this was following event-loop deployments which use an event-loop per verticle instance for scalability purpose.

== Miscellaneous

=== NetServer connect stream removals

`NetServer#connectStream()` has been removed. This stream was designed for Rx like languages and the actually don't provide any benefits at the expense of the API.

[source,java]
----
// 4.x
server.connectStream().handler(socket -> ...);

// 5.0
server.connectHandler(socket -> ...).listen();
----

=== TimeoutStream removal

`TimeoutStream` has been removed. This stream was designed for Rx like languages and the actually don't provide any benefits at the expense of the API. Instead, the framework scheduler should be used instead along with a Vert.x context.

[source,java]
----
// 4.x
vertx.periodicStream(1L).handler(timerID -> ...);

// 5.0
server.setPeriodic(1L, timerID -> ...);
----

For RxJava like integrations

[source,java]
----
// 4.x
Observable<Long> timer = vertx.periodicStream(1000).toObservable();

// 5.0
Scheduler scheduler = RxHelper.scheduler(vertx);
Observable<Long> timer = Observable.interval(100, 100, TimeUnit.MILLISECONDS, scheduler);
----

=== keyCertOptions key manager mapper removal

`KeyCertOptions#keyManagerMapper()` method has been removed in {VertX5}, implementors must instead implement `keyManagerFactoryMappermethod` that provides the opportunity to cache the `KeyManagerFactory` to the implementor that controls the lifecycle of the key manager.

=== Removal of execute blocking methods with a handler of promise

The API for executing blocking actions uses a pattern with handler completing or failing a promise, instead this can be replaced with `java.util.concurrent.Callable` that returns the same value or throws an exception.

[source,java]
----
// 4.x
Future<String> fut = vertx.executeBlocking(promise -> promise.complete("result"));

// 5.0
Future<String> fut = vertx.executeBlocking(() -> "result");
----

=== processArgs methods deprecated

`io.vertx.core.Context#processArgs` and `io.vertx.core.AbstractVerticle#processArgs` are deprecated.

As of version {v5}, {VertX} is no longer tightly coupled to the CLI.

=== Netty type usage removals

The Vert.x API exposes the Netty API in its public API, allowing interactions with the Netty API. Since Netty is evolving toward Netty 5, we should remove Netty API from the Vert.x public API in {VertX5} to have the opportunity to change the underlying Netty version used by {VertX} without worrying about the version of the Netty version.

Such API continues to exist in {VertX5} but is moved to internal API which is not contractual, therefore experimented users of this API can continue to use it granted that the version of {VertX5} uses Netty 4.

[source,java]
----
// 4.x
ByteBuf bb = buff.getByteBuf();
Buffer buf = Buffer.buffer(bb);
EventLoopGroup group = vertx.nettyEventLoopGroup();

// 5.0
ByteBuf bb = ((BufferInternal)buff).getByteBuf();
buf = BufferInternal.buffer(bb);
group = ((VertxInternal)vertx).nettyEventLoopGroup();
----
